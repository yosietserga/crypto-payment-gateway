/**
 * Binance API Integration Module
 * Provides binance.com integration for the payment gateway
 */

// Utility Functions

/**
 * Format crypto amount with appropriate precision
 * @param {string|number} amount - Amount to format
 * @param {string} asset - Crypto asset symbol
 * @returns {string} - Formatted amount
 * Format cryptocurrency amount with appropriate decimal places
 * @param {number|string} amount - Amount to format
 * @param {string} currency - Currency code
 * @returns {string} Formatted amount
 */
function formatCryptoAmount(amount, currency) {
    if (!amount) return '0';
    
    // Convert to number if it's a string
    const numAmount = typeof amount === 'string' ? parseFloat(amount) : amount;
    
    // Define decimal places based on currency
    const decimalPlaces = {
        'BTC': 8,
        'ETH': 6,
}

/**
 * Format timestamp to readable date/time
 * @param {number} timestamp - Unix timestamp (ms)
 * @returns {string} - Formatted date/time
 */
function formatTimestamp(timestamp) {
    if (!timestamp) return 'Unknown';
    
    const date = new Date(parseInt(timestamp));
    return date.toLocaleString();
}

/**
 * Get a cryptocurrency icon HTML
 * @param {string} currency - Currency code
 * @returns {string} - HTML for the currency icon
 */
function getCurrencyIcon(currency) {
    const lowerCurrency = (currency || '').toLowerCase();
    
    // Common cryptocurrency icons
    const icons = {
        'btc': '<i class="bi bi-currency-bitcoin text-warning"></i>',
        'eth': '<i class="bi bi-ethereum text-primary"></i>',
        'usdt': '<i class="bi bi-cash-coin text-success"></i>',
        'usdc': '<i class="bi bi-cash text-primary"></i>',
        'busd': '<i class="bi bi-cash-stack text-warning"></i>',
        'bnb': '<i class="bi bi-coin text-warning"></i>',
        'xrp': '<i class="bi bi-currency-exchange text-info"></i>',
        'sol': '<i class="bi bi-sun text-primary"></i>',
        'ada': '<i class="bi bi-shield text-danger"></i>',
        'doge': '<i class="bi bi-currency-dollar text-warning"></i>',
        'dot': '<i class="bi bi-record-circle text-danger"></i>',
        'dai': '<i class="bi bi-currency-dollar text-warning"></i>',
    };
    
    return icons[lowerCurrency] || `<i class="bi bi-coin text-secondary"></i>`;
}

/**
 * Get transaction status text based on status code
 * @param {Object} tx - Transaction object with status property
 * @returns {string} - Status text
 */
function getTransactionStatus(tx) {
    // For deposits
    if (tx.type === 'deposit' || (tx.status !== undefined && (tx.txId || tx.insertTime))) {
        // Binance deposit status codes
        const depositStatuses = {
            0: 'Pending',
            1: 'Success',
            2: 'Processing',
            3: 'Failed',
            4: 'Refunded',
        };
        return depositStatuses[tx.status] || 'Unknown';
    }
    
    // For withdrawals
    if (tx.type === 'withdrawal' || (tx.status !== undefined && tx.applyTime)) {
        // Binance withdrawal status codes
        const withdrawalStatuses = {
            0: 'Email Sent',
            1: 'Cancelled',
            2: 'Awaiting Approval',
            3: 'Rejected',
            4: 'Processing',
            5: 'Failed',
            6: 'Completed',
        };
        return withdrawalStatuses[tx.status] || 'Unknown';
    }
    
    // For payment requests
    if (tx.status && typeof tx.status === 'string') {
        return tx.status.charAt(0).toUpperCase() + tx.status.slice(1);
    }
    
    // Default fallback
    return 'Unknown';
}

/**
 * Get status class for badges based on status text
 * @param {string} status - Status text
 * @returns {string} - Bootstrap class name
 */
function getStatusClass(status) {
    const statusLower = status.toLowerCase();
    
    if (['success', 'completed', 'confirmed'].includes(statusLower)) {
        return 'bg-success';
    } else if (['pending', 'processing', 'awaiting approval', 'email sent'].includes(statusLower)) {
        return 'bg-warning';
    } else if (['cancelled', 'rejected', 'failed', 'error', 'refunded'].includes(statusLower)) {
        return 'bg-danger';
    } else {
        return 'bg-info';
    }
}

// Binance API class
class BinanceAPI {
    constructor() {
        this.paymentApi = new PaymentAPI();
        this.apiBaseUrl = '/api/binance';
        this.loadApiKeys();
    }
    
    /**
     * Load API keys from local storage
     */
    loadApiKeys() {
        this.apiKey = localStorage.getItem('binance_api_key');
        this.apiSecret = localStorage.getItem('binance_api_secret');
        this.isConfigured = !!(this.apiKey && this.apiSecret);
    }
    
    /**
     * Save API keys to local storage
     * @param {string} apiKey - Binance API key
     * @param {string} apiSecret - Binance API secret
     * @returns {boolean} - Success flag
     */
    saveApiKeys(apiKey, apiSecret) {
        if (!apiKey || !apiSecret) return false;
        
        localStorage.setItem('binance_api_key', apiKey);
        localStorage.setItem('binance_api_secret', apiSecret);
        
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.isConfigured = true;
        
        return true;
    }
    
    /**
     * Test connection to Binance API
     * @returns {Promise<boolean>} - True if connection successful
     */
    async testConnection() {
        if (!this.isConfigured) return false;
        
        try {
            const result = await this.paymentApi.request(`${this.apiBaseUrl}/ping`, {
                headers: {
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                }
            });
            
            return result && result.success === true;
        } catch (error) {
            console.error('Binance connection test failed:', error);
            return false;
        }
    }
    
    /**
     * Get account balances
     * @returns {Promise<Array>} - Array of balance objects
     */
    async getBalances() {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/account/balances`, {
                headers: {
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                }
            });
            
            return data.balances || [];
        } catch (error) {
            console.error('Error fetching balances:', error);
            throw error;
        }
    }
    
    /**
     * Get deposit history
     * @param {Object} options - Filter options
     * @returns {Promise<Array>} - Array of deposit objects
     */
    async getDeposits(options = {}) {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/deposits`, {
                headers: {
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                }
            });
            
            return data.deposits || [];
        } catch (error) {
            console.error('Error fetching deposits:', error);
            throw error;
        }
    }
    
    /**
     * Get withdrawal history
     * @param {Object} options - Filter options
     * @returns {Promise<Array>} - Array of withdrawal objects
     */
    async getWithdrawals(options = {}) {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/withdrawals`, {
                headers: {
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                }
            });
            
            return data.withdrawals || [];
        } catch (error) {
            console.error('Error fetching withdrawals:', error);
            throw error;
        }
    }
    
    /**
     * Create a withdrawal
     * @param {Object} withdrawalData - Withdrawal details
     * @returns {Promise<Object>} - Created withdrawal object
     */
    async createWithdrawal(withdrawalData) {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/withdrawals`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                },
                body: JSON.stringify(withdrawalData)
            });
            
            return data.withdrawal || null;
        } catch (error) {
            console.error('Error creating withdrawal:', error);
            throw error;
        }
    }
    
    /**
     * Get payment requests
     * @returns {Promise<Array>} - Array of payment request objects
     */
    async getPaymentRequests() {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/payment-requests`, {
                headers: {
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                }
            });
            
            return data.paymentRequests || [];
        } catch (error) {
            console.error('Error fetching payment requests:', error);
            throw error;
        }
    }
    
    /**
     * Create a payment request
     * @param {Object} paymentData - Payment request details
     * @returns {Promise<Object>} - Created payment request object
     */
    async createPaymentRequest(paymentData) {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/payment-requests`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-binance-api-key': this.apiKey,
                    'x-binance-api-secret': this.apiSecret
                },
                body: JSON.stringify(paymentData)
            });
            
            return data.paymentRequest || null;
        } catch (error) {
            console.error('Error creating payment request:', error);
            throw error;
        }
    }
}

// Binance API handler class
class BinanceAPI {
    constructor() {
        this.apiBaseUrl = '/api/v1/binance';
        this.paymentApi = new PaymentAPI();
        this.isConfigured = false;
        this.supportedCurrencies = ['BTC', 'ETH', 'USDT', 'BNB', 'BUSD'];
        this.supportedNetworks = ['BEP20', 'ERC20', 'TRC20'];
        
        // Check if API keys are saved
        this.checkSavedCredentials();
    }
    
    /**
     * Check if API credentials are saved in localStorage
     */
    checkSavedCredentials() {
        const apiKey = localStorage.getItem('binance_api_key');
        const hasSecret = localStorage.getItem('has_binance_secret') === 'true';
        const network = localStorage.getItem('binance_network') || 'BEP20';
        
        if (apiKey && hasSecret) {
            this.isConfigured = true;
            this.network = network;
        } else {
            this.isConfigured = false;
        }
        
        return this.isConfigured;
    }
    
    /**
     * Save API credentials to localStorage (only the key and a flag for secret)
     * @param {string} apiKey - Binance API key
     * @param {string} apiSecret - Binance API secret
     * @param {string} network - Selected network (BEP20, ERC20, TRC20)
     */
    saveCredentials(apiKey, apiSecret, network) {
        localStorage.setItem('binance_api_key', apiKey);
        localStorage.setItem('has_binance_secret', 'true');
        localStorage.setItem('binance_network', network);
        this.isConfigured = true;
        this.network = network;
    }
    
    /**
     * Clear saved credentials
     */
    clearCredentials() {
        localStorage.removeItem('binance_api_key');
        localStorage.removeItem('has_binance_secret');
        localStorage.removeItem('binance_network');
        this.isConfigured = false;
    }
    
    /**
     * Test connection to Binance API
     * @returns {Promise<boolean>} True if connection successful
     */
    async testConnection() {
        try {
            const apiKey = localStorage.getItem('binance_api_key');
            const apiSecret = ''; // We don't store the actual secret in localStorage
            
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/test-connection`, {
                method: 'POST',
                body: JSON.stringify({
                    apiKey,
                    apiSecret, // Backend will check if secret is needed
                    validateConfig: true
                })
            });
            
            return data.success === true;
        } catch (error) {
            console.error('Error testing connection:', error);
            return false;
        }
    }
    
    /**
     * Register API keys with the server
     * @param {string} apiKey - Binance API key
     * @param {string} apiSecret - Binance API secret
     * @param {string} network - Selected network (BEP20, ERC20, TRC20)
     * @returns {Promise<Object>} Registration result
     */
    async registerApiKeys(apiKey, apiSecret, network) {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/register-api-keys`, {
                method: 'POST',
                body: JSON.stringify({
                    apiKey,
                    apiSecret,
                    network
                })
            });
            
            if (data.success) {
                this.saveCredentials(apiKey, apiSecret, network);
            }
            
            return data;
        } catch (error) {
            console.error('Error registering API keys:', error);
            throw error;
        }
    }
    
    /**
     * Get account information and balances
     * @returns {Promise<Object>} Account information
     */
    async getAccountInfo() {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/account`);
            return data;
        } catch (error) {
            console.error('Error fetching account info:', error);
            throw error;
        }
    }
    
    /**
     * Get wallet balances
     * @returns {Promise<Array>} Account balances
     */
    async getBalances() {
        try {
            const data = await this.paymentApi.request(`${this.apiBaseUrl}/balances`);
            return data.balances || [];
        } catch (error) {
            console.error('Error fetching balances:', error);
            throw error;
        }
    }
    
    /**
     * Get deposit history
     * @param {Object} options - Filter options
     * @returns {Promise<Array>} Deposit history
     */
    async getDepositHistory(options = {}) {
        try {
            const queryParams = new URLSearchParams(options).toString();
            const url = `${this.apiBaseUrl}/deposit-history${queryParams ? `?${queryParams}` : ''}`;
            
            const data = await this.paymentApi.request(url);
            return data.deposits || [];
        } catch (error) {
            console.error('Error fetching deposit history:', error);
            throw error;
        }
    }
    
    /**
     * Get withdrawal history
     * @param {Object} options - Filter options
     * @returns {Promise<Array>} Withdrawal history
     */
    async getWithdrawalHistory(options = {}) {
        try {
            const queryParams = new URLSearchParams(options).toString();
            const url = `${this.apiBaseUrl}/withdrawal-history${queryParams ? `?${queryParams}` : ''}`;
            
            const data = await this.paymentApi.request(url);
            return data.withdrawals || [];
        } catch (error) {
            console.error('Error fetching withdrawal history:', error);
            throw error;
        }
    }
    
    /**
     * Get transaction details by ID
     * @param {string} txType - Transaction type (deposit/withdrawal)
     * @param {string} txId - Transaction ID
     * @returns {Promise<Object>} Transaction details
     */
    async getTransactionDetails(txType, txId) {
        try {
            const url = `${this.apiBaseUrl}/transactions/${txType}/${txId}`;
            const data = await this.paymentApi.request(url);
            return data.transaction || {};
        } catch (error) {
            console.error('Error fetching transaction details:', error);
            throw error;
    }
}

/**
 * Get transaction details by ID
 * @param {string} txType - Transaction type (deposit/withdrawal)
 * @param {string} txId - Transaction ID
 * @returns {Promise<Object>} Transaction details
 */
async getTransactionDetails(txType, txId) {
    try {
        const url = `${this.apiBaseUrl}/transactions/${txType}/${txId}`;
        const data = await this.paymentApi.request(url);
        return data.transaction || {};
    } catch (error) {
        console.error('Error fetching transaction details:', error);
        throw error;
    }
}

/**
 * Create a withdrawal from Binance
 * @param {Object} withdrawalData - Withdrawal data
 * @returns {Promise<Object>} Withdrawal result
 */
async createWithdrawal(withdrawalData) {
    try {
        const data = await this.paymentApi.request(`${this.apiBaseUrl}/withdrawals`, {
            method: 'POST',
            body: JSON.stringify(withdrawalData)
        });
        return data;
    } catch (error) {
        console.error('Error creating withdrawal:', error);
        throw error;
    }
}
}

// UI Controller for Binance dashboard
class BinanceDashboardUI {
    constructor() {
        this.binanceApi = new BinanceAPI();
        this.initElements();
        this.addEventListeners();
        this.initialize();
    }
    
    initElements() {
        // Connection status elements
        this.connectionIndicator = document.getElementById('connection-status-indicator');
        this.connectionMessage = document.getElementById('connection-status-message');
        this.connectionStatus = document.getElementById('connection-status');
        this.configureBtn = document.getElementById('configure-binance-btn');
        
        // Dashboard elements
        this.totalBalanceValue = document.getElementById('total-balance-value');
        this.activeCoinsCount = document.getElementById('active-coins-count');
        this.lastTransactionTime = document.getElementById('last-transaction-time');
        this.lastTransactionInfo = document.getElementById('last-transaction-info');
        
        // Balance elements
        this.balancesContainer = document.getElementById('wallet-balances');
        this.balancesLoader = document.getElementById('balances-loader');
        this.walletBalancesContainer = document.getElementById('wallet-balances-container');
        
        // Transaction tables
        this.allTransactionsTable = document.getElementById('all-transactions-table-body');
        this.depositsTable = document.getElementById('deposits-table-body');
        this.withdrawalsTable = document.getElementById('withdrawals-table-body');
        this.paymentRequestsTable = document.getElementById('payment-requests-table-body');
        
        // Modals
        this.apiConfigModal = bootstrap.Modal.getOrCreateInstance(document.getElementById('configure-api-modal'));
        this.transactionDetailsModal = bootstrap.Modal.getOrCreateInstance(document.getElementById('transaction-details-modal'));
        this.transactionDetailsContent = document.getElementById('transaction-details-content');
        
        // Forms
        this.apiKeyInput = document.getElementById('api-key');
        this.apiSecretInput = document.getElementById('api-secret');
        this.withdrawalForm = document.getElementById('withdrawal-form');
        this.paymentRequestForm = document.getElementById('payment-request-form');
        
        // Buttons and actions
        this.refreshBtn = document.getElementById('refresh-btn');
        this.saveApiKeysBtn = document.getElementById('save-api-keys-btn');
        
        // Current active tab
        this.currentTab = 'dashboard';
    }
    
    addEventListeners() {
        // Configure API keys
        if (this.configureBtn) {
            this.configureBtn.addEventListener('click', () => this.openConfigureModal());
        }
        
        if (this.saveApiKeysBtn) {
            this.saveApiKeysBtn.addEventListener('click', () => this.saveApiKeys());
        }
        
        // Refresh data
        if (this.refreshBtn) {
            this.refreshBtn.addEventListener('click', () => this.refreshData());
        }
        
        // Handle withdrawal form submission
        if (this.withdrawalForm) {
            this.withdrawalForm.addEventListener('submit', (e) => {
                e.preventDefault();
                this.handleWithdrawalSubmit();
            });
        }
        
        // Handle payment request form submission
        if (this.paymentRequestForm) {
            this.paymentRequestForm.addEventListener('submit', (e) => {
                e.preventDefault();
                this.handlePaymentRequestSubmit();
            });
        }
        
        // Handle tab changes
        document.querySelectorAll('.binance-tab-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                const tabId = e.currentTarget.dataset.tab;
                this.handleTabChange(tabId);
            });
        });
        
        // Handle transaction details
        document.addEventListener('click', (e) => {
            const viewDetailsBtn = e.target.closest('.view-transaction-btn');
            if (viewDetailsBtn) {
                const txType = viewDetailsBtn.dataset.type;
                const txId = viewDetailsBtn.dataset.id;
                this.showTransactionDetails(txType, txId);
            }
        });
    }
    
    /**
     * Initialize the dashboard
     */
    async initialize() {
        await this.checkConnection();
        if (this.binanceApi.isConfigured) {
            this.loadBalances();
            this.loadTransactions();
        } else {
            this.displayConfigurationNeeded();
        }
    }
    
    /**
     * Check connection status
     */
    async checkConnection() {
        try {
            // Update UI to loading state
            this.updateConnectionStatus('checking');
            
            if (!this.binanceApi.isConfigured) {
                this.updateConnectionStatus('not-configured');
                return false;
            }
            
            const isConnected = await this.binanceApi.testConnection();
            this.updateConnectionStatus(isConnected ? 'connected' : 'error');
            return isConnected;
        } catch (error) {
            console.error('Error checking connection:', error);
            this.updateConnectionStatus('error');
            return false;
        }
    }
    
    /**
    /**
     * Display configuration needed message
     */
    displayConfigurationNeeded() {
        // Display message in all containers
        if (this.balancesContainer) {
            this.balancesContainer.innerHTML = `
                <div class="alert alert-warning">
                    <i class="bi bi-exclamation-triangle me-2"></i> Please configure your Binance API keys to view your wallet balances.
                </div>
            `;
        }
        
        if (this.walletBalancesContainer) {
            this.walletBalancesContainer.innerHTML = `
                <div class="col-12 text-center py-4">
                    <div class="alert alert-warning">
                        <i class="bi bi-exclamation-triangle me-2"></i> Please configure your Binance API keys to view your detailed wallet information.
                    </div>
                </div>
            `;
        }
        
        if (this.allTransactionsTable) {
            this.allTransactionsTable.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center">
                        <div class="alert alert-warning mb-0">
                            <i class="bi bi-exclamation-triangle me-2"></i> Please configure your Binance API keys to view your transactions.
                        </div>
                    </td>
                </tr>
            `;
        }
        
        if (this.depositsTable) {
            this.depositsTable.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center">
                        <div class="alert alert-warning mb-0">
                            <i class="bi bi-exclamation-triangle me-2"></i> Please configure your Binance API keys to view your deposits.
                        </div>
                    </td>
                </tr>
            `;
        }
        
        if (this.withdrawalsTable) {
            this.withdrawalsTable.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center">
                        <div class="alert alert-warning mb-0">
                            <i class="bi bi-exclamation-triangle me-2"></i> Please configure your Binance API keys to view your withdrawals.
                        </div>
                    </td>
                </tr>
            `;
        }
        
        if (this.paymentRequestsTable) {
            this.paymentRequestsTable.innerHTML = `
                <tr>
                    <td colspan="5" class="text-center">
                        <div class="alert alert-warning mb-0">
                            <i class="bi bi-exclamation-triangle me-2"></i> Please configure your Binance API keys to view your payment requests.
                        </div>
                    </td>
                </tr>
            `;
        }
        
        // Reset dashboard metrics
        if (this.totalBalanceValue) {
            this.totalBalanceValue.textContent = 'Not Available';
        }
        if (this.activeCoinsCount) {
            this.activeCoinsCount.textContent = '0';
        }
        if (this.lastTransactionTime) {
            this.lastTransactionTime.textContent = 'No Data';
        }
        if (this.lastTransactionInfo) {
    }

    // Sort by value (highest first)
    balances.sort((a, b) => {
        const aValue = parseFloat(a.free) + parseFloat(a.locked);
        const bValue = parseFloat(b.free) + parseFloat(b.locked);
        return bValue - aValue;
    });

    let balancesHtml = '';

    balances.forEach(balance => {
        // Only show non-zero balances
        if (parseFloat(balance.free) > 0 || parseFloat(balance.locked) > 0) {
            const total = parseFloat(balance.free) + parseFloat(balance.locked);

            balancesHtml += `
                <div class="balance-item mb-3 p-3 border rounded">
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="d-flex align-items-center">
                            ${getCurrencyIcon(balance.asset)}
                            <div class="ms-2">
                                <div class="fw-bold">${balance.asset}</div>
            // Select the saved network
            const savedNetwork = localStorage.getItem('binance_network') || 'BEP20';
            document.querySelector('input[name="network"][value="${savedNetwork}"]').checked = true;
        }
        
        this.apiConfigModal.show();
    }
    
    /**
     * Save API keys from the modal form
     */
    async saveApiKeys() {
        try {
            const apiKey = this.apiKeyInput.value.trim();
            const apiSecret = this.apiSecretInput.value.trim();
            const network = document.querySelector('input[name="network"]:checked').value;
            
            if (!apiKey) {
                alert('Please enter a valid API key');
                return;
            }
            
            // Show loading state
            this.saveApiKeysBtn.disabled = true;
            this.saveApiKeysBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span> Connecting...';
            
            // Register keys with the server
            const result = await this.binanceApi.registerApiKeys(apiKey, apiSecret, network);
            
            if (result.success) {
                this.apiConfigModal.hide();
                this.updateConnectionStatus('connected');
                
                // Reload dashboard data
                this.loadBalances();
                this.loadTransactions();
            } else {
                alert(`Error: ${result.message || 'Failed to register API keys'}`);
            }
        } catch (error) {
            console.error('Error saving API keys:', error);
            alert(`Error: ${error.message || 'Failed to save API keys'}`);
        } finally {
            // Reset button state
            this.saveApiKeysBtn.disabled = false;
            this.saveApiKeysBtn.innerHTML = 'Save & Connect';
        }
    }
    
    /**
     * Load wallet balances and update dashboard metrics
     */
    async loadBalances() {
        if (!this.balancesContainer) return;
        
        try {
            // Show loader
            if (this.balancesLoader) {
                this.balancesLoader.classList.remove('d-none');
            }
            
            const balances = await this.binanceApi.getBalances();
            
            // Hide loader
            if (this.balancesLoader) {
                this.balancesLoader.classList.add('d-none');
            }
            
            // Update dashboard metrics if on dashboard tab
            if (this.currentTab === 'dashboard') {
                this.updateDashboardMetrics(balances);
            }
            
            if (!balances || balances.length === 0) {
                if (this.balancesContainer) {
                    this.balancesContainer.innerHTML = `
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle me-2"></i> No balances found in your Binance wallet.
                        </div>
                    `;
                }
                return;
            }
            
            // Sort by value (highest first)
            balances.sort((a, b) => {
                const aValue = parseFloat(a.free) + parseFloat(a.locked);
                const bValue = parseFloat(b.free) + parseFloat(b.locked);
                return bValue - aValue;
            });
            
            let balancesHtml = '';
            
            balances.forEach(balance => {
                // Only show non-zero balances
                if (parseFloat(balance.free) > 0 || parseFloat(balance.locked) > 0) {
                    const total = parseFloat(balance.free) + parseFloat(balance.locked);
                    
                    balancesHtml += `
                        <div class="balance-item mb-3 p-3 border rounded">
                            <div class="d-flex justify-content-between align-items-center">
                                <div class="d-flex align-items-center">
                                    ${getCurrencyIcon(balance.asset)}
                                    <div class="ms-2">
                                        <div class="fw-bold">${balance.asset}</div>
                                    </div>
                                </div>
                                <div class="text-end">
                                    <div class="balance-amount fw-bold">${formatCryptoAmount(total, balance.asset)}</div>
                                    <div class="balance-details small text-muted">
                                        Available: ${formatCryptoAmount(balance.free, balance.asset)}
                                        ${parseFloat(balance.locked) > 0 ? `<br>Locked: ${formatCryptoAmount(balance.locked, balance.asset)}` : ''}
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
            
            if (this.balancesContainer) {
                this.balancesContainer.innerHTML = balancesHtml || `
                    <div class="alert alert-info">
                        <i class="bi bi-info-circle me-2"></i> No balances found in your Binance wallet.
                    </div>
                `;
            }
        } catch (error) {
            console.error('Error loading balances:', error);
            
            // Hide loader
            if (this.balancesLoader) {
                this.balancesLoader.classList.add('d-none');
            }
            
            if (this.balancesContainer) {
                this.balancesContainer.innerHTML = `
                    <div class="alert alert-danger">
                        <i class="bi bi-exclamation-triangle me-2"></i> Error loading balances: ${error.message}
                    </div>
                `;
            }
        }
    }
    
    /**
     * Load transactions
     */
    async loadTransactions() {
        try {
            // Show loading state
            if (this.allTransactionsTable) {
                this.allTransactionsTable.innerHTML = '<tr><td colspan="6" class="text-center py-4"><div class="spinner-border spinner-border-sm me-2" role="status"></div> Loading transactions...</td></tr>';
            }
            
            if (this.depositsTable) {
                this.depositsTable.innerHTML = '<tr><td colspan="6" class="text-center py-4"><div class="spinner-border spinner-border-sm me-2" role="status"></div> Loading deposits...</td></tr>';
            }
            
            if (this.withdrawalsTable) {
                this.withdrawalsTable.innerHTML = '<tr><td colspan="6" class="text-center py-4"><div class="spinner-border spinner-border-sm me-2" role="status"></div> Loading withdrawals...</td></tr>';
            }
            
            // Fetch transaction history from server
            const [deposits, withdrawals] = await Promise.all([
                this.binanceApi.getDeposits(),
                this.binanceApi.getWithdrawals()
            ]);
            
            // Combine transactions for the all transactions view
            const allTransactions = [...deposits, ...withdrawals];
            
            // Update dashboard metrics if on dashboard tab
            if (this.currentTab === 'dashboard') {
                this.updateLastTransactionInfo(allTransactions);
            }
            
            // Display transactions
            this.displayAllTransactions(allTransactions);
            this.displayDeposits(deposits);
            this.displayWithdrawals(withdrawals);
            
            return allTransactions;
            
        } catch (error) {
            console.error('Error loading transactions:', error);
            const errorMessage = `
                <tr>
                    <td colspan="6" class="text-center py-4">
                        <div class="alert alert-danger mb-0" role="alert">
                            <i class="bi bi-exclamation-triangle me-2"></i> Error loading transactions: ${error.message || 'Unknown error'}
                        </div>
                    </td>
                </tr>
            `;
            
            if (this.allTransactionsTable) {
                this.allTransactionsTable.innerHTML = errorMessage;
            }
            
            if (this.depositsTable) {
                this.depositsTable.innerHTML = errorMessage;
            }
            
            if (this.withdrawalsTable) {
                this.withdrawalsTable.innerHTML = errorMessage;
            }
            
            return [];
        }
    }
    
    /**
     * Display all transactions in the combined view
     * @param {Array} transactions - Combined array of deposits and withdrawals
     */
    displayAllTransactions(transactions) {
        if (!this.allTransactionsTable) return;
        
        if (!transactions || transactions.length === 0) {
            this.allTransactionsTable.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4">
                        <div class="alert alert-info mb-0" role="alert">
                            <i class="bi bi-info-circle me-2"></i> No transactions found.
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Sort by timestamp (newest first)
        transactions.sort((a, b) => {
            const aTime = a.insertTime || a.applyTime || a.time || 0;
            const bTime = b.insertTime || b.applyTime || b.time || 0;
            return bTime - aTime;
        });
        
        let html = '';
        
        transactions.forEach(tx => {
            // Determine if this is a deposit or withdrawal based on the transaction properties
            const isDeposit = tx.type === 'deposit' || tx.status === 0 || tx.status === 1 || !!tx.txId;
            const type = isDeposit ? 'Deposit' : 'Withdrawal';
            const typeClass = isDeposit ? 'success' : 'warning';
            
            // Determine transaction status and class
            const status = this.getTransactionStatus(tx);
            const statusClass = this.getStatusClass(status);
            
            // Format timestamp
            const timestamp = tx.insertTime || tx.applyTime || tx.time || Date.now();
            const formattedTime = this.formatTimestamp(timestamp);
            
            html += `
                <tr>
                    <td>
                        <span class="badge bg-${typeClass}">${type}</span>
                    </td>
                    <td>${tx.coin || tx.asset || '-'}</td>
                    <td>${this.formatCryptoAmount(tx.amount, tx.coin)}</td>
                    <td><span class="badge bg-${statusClass}">${status}</span></td>
                    <td>${formattedTime}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-transaction-btn" data-type="${isDeposit ? 'deposit' : 'withdrawal'}" data-id="${tx.id || tx.txId || ''}">
                            <i class="bi bi-eye"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        this.allTransactionsTable.innerHTML = html;
    }
    
    /**
     * Display deposits in the deposits tab
     * @param {Array} deposits - Array of deposit transactions
     */
    displayDeposits(deposits) {
        if (!this.depositsTable) return;
        
        if (!deposits || deposits.length === 0) {
            this.depositsTable.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4">
                        <div class="alert alert-info mb-0" role="alert">
                            <i class="bi bi-info-circle me-2"></i> No deposits found.
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Sort by timestamp (newest first)
        deposits.sort((a, b) => (b.insertTime || 0) - (a.insertTime || 0));
        
        let html = '';
        
        deposits.forEach(deposit => {
            const status = this.getTransactionStatus(deposit);
            const statusClass = this.getStatusClass(status);
            
            const timestamp = deposit.insertTime || Date.now();
            const formattedTime = this.formatTimestamp(timestamp);
            
            html += `
                <tr>
                    <td>${deposit.txId || '-'}</td>
                    <td>${deposit.coin || '-'}</td>
                    <td>${this.formatCryptoAmount(deposit.amount, deposit.coin)}</td>
                    <td><span class="badge bg-${statusClass}">${status}</span></td>
                    <td>${formattedTime}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-transaction-btn" data-type="deposit" data-id="${deposit.txId || ''}">
                            <i class="bi bi-eye"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        this.depositsTable.innerHTML = html;
    }
    
    /**
     * Display withdrawals in the withdrawals tab
     * @param {Array} withdrawals - Array of withdrawal transactions
     */
    displayWithdrawals(withdrawals) {
        if (!this.withdrawalsTable) return;
        
        if (!withdrawals || withdrawals.length === 0) {
            this.withdrawalsTable.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4">
                        <div class="alert alert-info mb-0" role="alert">
                            <i class="bi bi-info-circle me-2"></i> No withdrawals found.
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Sort by timestamp (newest first)
        withdrawals.sort((a, b) => (b.applyTime || 0) - (a.applyTime || 0));
        
        let html = '';
        
        withdrawals.forEach(withdrawal => {
            const status = this.getTransactionStatus(withdrawal);
            const statusClass = this.getStatusClass(status);
            
            const timestamp = withdrawal.applyTime || Date.now();
            const formattedTime = this.formatTimestamp(timestamp);
            
            html += `
                <tr>
                    <td>${withdrawal.id || '-'}</td>
                    <td>${withdrawal.coin || withdrawal.asset || '-'}</td>
                    <td>${this.formatCryptoAmount(withdrawal.amount, withdrawal.coin)}</td>
                    <td><span class="badge bg-${statusClass}">${status}</span></td>
                    <td>${formattedTime}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-transaction-btn" data-type="withdrawal" data-id="${withdrawal.id || ''}">
                            <i class="bi bi-eye"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        this.withdrawalsTable.innerHTML = html;
    }
    
    /**
     * Display combined transactions
     * @param {Array} deposits - Deposit transactions
     * @param {Array} withdrawals - Withdrawal transactions
     */
    displayAllTransactions(deposits, withdrawals) {
        // Combine and sort all transactions by time (newest first)
        const allTransactions = [
            ...deposits.map(tx => ({ ...tx, type: 'deposit' })),
            ...withdrawals.map(tx => ({ ...tx, type: 'withdrawal' }))
        ].sort((a, b) => {
            // Use insertTime for deposits, applyTime for withdrawals
            const aTime = a.type === 'deposit' ? a.insertTime : a.applyTime;
            const bTime = b.type === 'deposit' ? b.insertTime : b.applyTime;
            return bTime - aTime;
        });
        
        if (allTransactions.length === 0) {
            this.allTransactionsTable.innerHTML = `
                <tr>
                    <td colspan="7" class="text-center py-4">
                        <div class="alert alert-info mb-0" role="alert">
                            <i class="bi bi-info-circle me-2"></i> No transactions found.
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        let html = '';
        allTransactions.forEach(tx => {
            const isDeposit = tx.type === 'deposit';
            const time = isDeposit ? tx.insertTime : tx.applyTime;
            const txId = isDeposit ? tx.txId : tx.id;
            const statusText = this.getStatusText(tx, isDeposit);
            const statusClass = this.getStatusClass(tx, isDeposit);
            
            html += `
                <tr>
                    <td>
                        <span class="badge ${isDeposit ? 'bg-success' : 'bg-primary'}">
                            <i class="bi ${isDeposit ? 'bi-download' : 'bi-upload'}"></i>
                            ${isDeposit ? 'Deposit' : 'Withdrawal'}
                        </span>
                    </td>
                    <td>${formatTimestamp(time)}</td>
                    <td>
                        <div class="d-flex align-items-center">
                            ${getCurrencyIcon(tx.coin)} ${tx.coin}
                        </div>
                    </td>
                    <td>${formatCryptoAmount(tx.amount, tx.coin)}</td>
                    <td><span class="badge ${statusClass}">${statusText}</span></td>
                    <td title="${tx.address}">${formatAddress(tx.address)}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-transaction-btn" data-type="${isDeposit ? 'deposit' : 'withdrawal'}" data-id="${txId}">
                            <i class="bi bi-eye"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        this.allTransactionsTable.innerHTML = html;
    }
    
    /**
     * Display deposits
     * @param {Array} deposits - Deposit transactions
     */
    displayDeposits(deposits) {
        if (deposits.length === 0) {
            this.depositsTable.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4">
                        <div class="alert alert-info mb-0" role="alert">
                            <i class="bi bi-info-circle me-2"></i> No deposit transactions found.
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Sort deposits by time (newest first)
        const sortedDeposits = [...deposits].sort((a, b) => b.insertTime - a.insertTime);
        
        let html = '';
        sortedDeposits.forEach(deposit => {
            const statusText = this.getStatusText(deposit, true);
            const statusClass = this.getStatusClass(deposit, true);
            
            html += `
                <tr>
                    <td>${formatTimestamp(deposit.insertTime)}</td>
                    <td>
                        <div class="d-flex align-items-center">
                            ${getCurrencyIcon(deposit.coin)} ${deposit.coin}
                        </div>
                    </td>
                    <td>${formatCryptoAmount(deposit.amount, deposit.coin)}</td>
                    <td><span class="badge ${statusClass}">${statusText}</span></td>
                    <td title="${deposit.address}">${formatAddress(deposit.address)}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-transaction-btn" data-type="deposit" data-id="${deposit.txId}">
                            <i class="bi bi-eye"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        this.depositsTable.innerHTML = html;
    }
    
    /**
     * Display withdrawals
     * @param {Array} withdrawals - Withdrawal transactions
     */
    displayWithdrawals(withdrawals) {
        if (withdrawals.length === 0) {
            this.withdrawalsTable.innerHTML = `
                <tr>
                    <td colspan="6" class="text-center py-4">
                        <div class="alert alert-info mb-0" role="alert">
                            <i class="bi bi-info-circle me-2"></i> No withdrawal transactions found.
                        </div>
                    </td>
                </tr>
            `;
            return;
        }
        
        // Sort withdrawals by time (newest first)
        const sortedWithdrawals = [...withdrawals].sort((a, b) => b.applyTime - a.applyTime);
        
        let html = '';
        sortedWithdrawals.forEach(withdrawal => {
            const statusText = this.getStatusText(withdrawal, false);
            const statusClass = this.getStatusClass(withdrawal, false);
            
            html += `
                <tr>
                    <td>${formatTimestamp(withdrawal.applyTime)}</td>
                    <td>
                        <div class="d-flex align-items-center">
                            ${getCurrencyIcon(withdrawal.coin)} ${withdrawal.coin}
                        </div>
                    </td>
                    <td>${formatCryptoAmount(withdrawal.amount, withdrawal.coin)}</td>
                    <td><span class="badge ${statusClass}">${statusText}</span></td>
                    <td title="${withdrawal.address}">${formatAddress(withdrawal.address)}</td>
                    <td>
                        <button class="btn btn-sm btn-outline-primary view-transaction-btn" data-type="withdrawal" data-id="${withdrawal.id}">
                            <i class="bi bi-eye"></i>
                        </button>
                    </td>
                </tr>
            `;
        });
        
        this.withdrawalsTable.innerHTML = html;
    }
    
    /**
     * Get status text for transaction
     * @param {Object} tx - Transaction object
     * @param {boolean} isDeposit - Whether transaction is a deposit
     * @returns {string} Status text
     */
    getStatusText(tx, isDeposit) {
        if (isDeposit) {
            // Deposit status: 0 pending, 1 success, other values are failures
            switch (tx.status) {
                case 0: return 'Pending';
                case 1: return 'Completed';
                case 6: return 'Credited';
                default: return 'Failed';
            }
        } else {
            // Withdrawal status: 0=Email Sent, 1=Cancelled, 2=Awaiting Approval, 3=Rejected,
            // 4=Processing, 5=Failure, 6=Completed
            switch (tx.status) {
                case 0: return 'Email Sent';
                case 1: return 'Cancelled';
                case 2: return 'Awaiting Approval';
                case 3: return 'Rejected';
                case 4: return 'Processing';
                case 5: return 'Failed';
                case 6: return 'Completed';
                default: return 'Unknown';
            }
        }
    }
     * Get status class for transaction
     * @param {Object} tx - Transaction object
     * @param {boolean} isDeposit - Whether transaction is a deposit
     * @returns {string} Status CSS class
     */
    getStatusClass(tx, isDeposit) {
        if (isDeposit) {
            switch (tx.status) {
                case 0: return 'bg-warning';
                case 1: return 'bg-success';
                case 6: return 'bg-success';
                default: return 'bg-danger';
            }
        } else {
            switch (tx.status) {
                case 0: return 'bg-info';
                case 1: return 'bg-secondary';
                case 2: return 'bg-warning';
                case 3: return 'bg-danger';
                case 4: return 'bg-primary';
                case 5: return 'bg-danger';
                case 6: return 'bg-success';
                default: return 'bg-secondary';
            }
        }
    }
    
    /**
     * Show transaction details
     * @param {string} txType - Transaction type (deposit/withdrawal)
     * @param {string} txId - Transaction ID
     */
    async showTransactionDetails(txType, txId) {
        try {
            // Show modal with loading state
            this.transactionDetailsContent.innerHTML = `
                <div class="text-center py-5">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Loading transaction details...</p>
                </div>
            `;
            this.transactionDetailsModal.show();
            
            // Fetch transaction details
            const details = await this.binanceApi.getTransactionDetails(txType, txId);
            
            // Create details view
            const isDeposit = txType === 'deposit';
            const timestamp = isDeposit ? details.insertTime : details.applyTime;
            const statusText = this.getStatusText(details, isDeposit);
            const statusClass = this.getStatusClass(details, isDeposit);
            
            let detailsHtml = `
                <div class="row">
                    <div class="col-md-6">
                        <h6>Transaction Info</h6>
                        <table class="table table-sm">
                            <tr>
                                <th>Type</th>
                                <td>
                                    <span class="badge ${isDeposit ? 'bg-success' : 'bg-primary'}">
                                        <i class="bi ${isDeposit ? 'bi-download' : 'bi-upload'}"></i>
                                        ${isDeposit ? 'Deposit' : 'Withdrawal'}
                                    </span>
                                </td>
                            </tr>
                            <tr>
                                <th>Date</th>
                                <td>${formatTimestamp(timestamp)}</td>
                            </tr>
                            <tr>
                                <th>Asset</th>
                                <td>
                                    <div class="d-flex align-items-center">
                                        ${getCurrencyIcon(details.coin)} ${details.coin}
                                    </div>
                                </td>
                            </tr>
                            <tr>
                                <th>Amount</th>
                                <td>${formatCryptoAmount(details.amount, details.coin)}</td>
                            </tr>
                            <tr>
                                <th>Status</th>
                                <td><span class="badge ${statusClass}">${statusText}</span></td>
                            </tr>
                        </table>
                    </div>
                    <div class="col-md-6">
                        <h6>Technical Details</h6>
                        <table class="table table-sm">
                            <tr>
                                <th>Transaction ID</th>
                                <td class="text-break">${isDeposit ? details.txId : details.id}</td>
                            </tr>
                            <tr>
                                <th>Address</th>
                                <td class="text-break">${details.address}</td>
                            </tr>
                            <tr>
                                <th>Network</th>
                                <td>${details.network || 'Default'}</td>
                            </tr>
            `;
            
            // Add additional fields specific to type
            if (isDeposit) {
                detailsHtml += `
                            <tr>
                                <th>Confirmations</th>
                                <td>${details.confirmTimes || 'N/A'}</td>
                            </tr>
                `;
            } else {
                detailsHtml += `
                            <tr>
                                <th>Withdrawal ID</th>
                                <td>${details.id}</td>
                            </tr>
                            <tr>
                                <th>Transaction Fee</th>
                                <td>${details.transactionFee} ${details.coin}</td>
                            </tr>
                `;
            }
            
            detailsHtml += `
                        </table>
                    </div>
                </div>
            `;
            
            this.transactionDetailsContent.innerHTML = detailsHtml;
        } catch (error) {
            console.error(`Error showing ${txType} details:`, error);
            this.transactionDetailsContent.innerHTML = `
                <div class="alert alert-danger" role="alert">
                    <i class="bi bi-exclamation-triangle me-2"></i>
                    Error loading transaction details: ${error.message || 'Unknown error'}
                </div>
            `;
        }
    }
    
    /**
     * Refresh all data
     */
    refreshData() {
        this.checkConnection();
        this.loadBalances();
        this.loadTransactions();
    }
}

// Initialize when document is ready
document.addEventListener('DOMContentLoaded', () => {
    // Only initialize on the Binance page
    if (document.getElementById('connection-status-indicator')) {
        const dashboard = new BinanceDashboardUI();
    }
});
